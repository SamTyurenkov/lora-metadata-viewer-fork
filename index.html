<!DOCTYPE html>
<html>
<head>
  <title>LoRA Metadata Viewer</title>
  <meta charset="UTF-8">
  <link id="favicon" rel="icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAL0SURBVDhPtZNfSFNRHMe/2929m9t1Tudymumcc1bWQyZCSpaBCWIqgnspfcmHgh6ioKfsobeEXnpIg+ghAtGyByNB9MF/EJkPKigT1Dmnc+7un/u/u7vd7l0mVERPfeBw+B3O98v5nt85+G88uN2rECbqR/V3JEdzhtZLV9V3my03k7FIQ05untnqdiRoktyNBgPT5lJzwaJ9k3P43KMvht+sHUl+MaBXB8feIZls94cCoBUqYUkCnU4Lf8AHVZYKm24n9mN+2+Sn91feLn1ziKJjg8WXH57p9UWP1CkJVCoVJIQMiXAUnlQMNAgsWVfgCoew6Xcir8rwWl9W+rSzvcMhFcVjT55fK9bk35OlgUgsBgkvQYJN4MDDgEzxkKR56DUFMOYVgoiSKCmv6KWVygZRK73V0XOhrNA0mEVQSsa9j9XADoJeH0KMD242iHSSBZ9MQSGXY2F9BzYmjnAwDp/Pny0aECvW5cid613VlEJ2/quPwQGnhffAhiAbwqzXhi2vE+W5BciSkSAVJAiTHgZzETguaQyHwxOEYML21LfUqIz05ZLyk5BSOpiaz+LExQq49hRCJDXOaeWg0lKw8jQK68woNZxCpblSR1Ikm7kDz+HheiKSRFFuFmrrteCRgpySo7HBjGqDGjkyJXYDXtB1Z6DWqCGTyZCdTUOr1RoyBmtu+yTHcLblhS24QuFMXjYhZE/7QdAhMFE/FPUmGKoqYSwrE1qrQ5LjIETwiBEwtfwlVJpfvEWZCtqKTUYqX9ggtlKZp0UoGkE6m0RlXS3A87BardBoNLDb7Z6+vr6Hov6Ymbm5zxsbG/zU1JRvz7kX5ziOPwwc8rF4nHe5XNz4+Pj8xMTELsuy/MfR0QFRk4nwk/nZ+QGGYfxDQ0P3b7S2dm5vb8fUOWo4dnacnZ2WtpaWliaeT8/GhLciJaTkkewPzMIQPxIGB189Fo7Kz8xMLwplJm6XxXJ6eGR4pL//WZNY/xOLxdLY3d1dc1T+BvAd/0w7pD7OdiEAAAAASUVORK5CYII=">
  <style>
    :root { --link:#4dabf7; --error:#dc3545; --databg:#f1f0e4; --datatxt:#c1c5c1; --string:#64ad15; --key:#8563c1; --number:#ff9e64; --boolean:#61aeee; --null:#e06c75;}
    :root { --bg:#F4F4F4; --vltheme:#3e3a3e; --ltheme:#dddbd6; --theme:#e2dfd8; --dtheme:#ebe8e1; --vdtheme:#f1f0e4; }
    .dark-theme { --bg:#121212; --vltheme:#c1c5c1; --ltheme:#2C2E33; --theme:#373A40; --dtheme:#25262b; --vdtheme:#1A1B26; --databg:#1A1B26; --string:#9ece6a; --key:#bb9af7;}
    body { font-family: Arial, sans-serif; background-color:var(--bg); color: var(--vltheme); margin:0; }
    .body-content { margin:10px; }
    .collapsible { cursor: pointer; user-select: none; margin-bottom: 5px; }
    .collapsible:hover { background-color: var(--vdtheme); border-radius: 10px; }
    .collapsible::before { content: "â–¼ "; display: inline-block; width: 1em; }
    .collapsible.active::before { content: "â–² "; }
    .content { display: none; padding: 5px; position: relative; }
    .copy-btn { position: absolute; right: 0.5em; background-color: transparent; border: none; color: grey; }
    .copy-btn:hover { background-color: grey; color: white; border-radius: 5px; }
    .note { font-size: 0.7em; font-style: italic; }
    .header, #settings-btn { margin:20px; font-size: 2em; font-weight: bold; }
    .footer { margin:10px; text-align: center; font-size: 0.9em; }
    #notificationPanel, #editorNotificationPanel, .error { text-align: center; color:var(--error); font-weight: bold; }
    #settings-btn { position: absolute; top: 0; right: 0; }
    #settings-btn.collapsible::before, #settings-btn.collapsible.active::before { content: none; }
    a { color: var(--link); font-weight: bold; text-decoration: none; }
    input, textarea, select { font-family: monospace; color: var(--vltheme); background-color: var(--ltheme); border-radius: 10px;  }
    input { padding:5px; }
    textarea { width: 100%; }
    select { font-size: 1.3em; padding: 5px;}
    hr { border: none; border-bottom: 1px solid var(--theme); }
    input[type=checkbox] { margin: 10px;}
    pre { margin: 0; }
    .json-data { overflow: overlay; background:var(--databg); color:var(--datatxt); padding: 10px; border-radius: 10px; }
    .editor-header { text-align: center; margin: 10px; }
    .editor-header button, .settings-button, .custom-file-upload { font-size: 1.1em; color: var(--vltheme); background-color: var(--ltheme); border: none; border-radius: 10px; padding:8px; }
    .editor-header button:hover, .settings-button:hover, .custom-file-upload:hover { background-color: var(--theme); }
    .custom-file-upload > input { display: none; }
    .svg-icon { width: 1em; height: 1em;}
    .svg-icon-lg { width: 3em; height: 3em;}
    .svg-icon path, .svg-icon polygon, .svg-icon rect { fill: var(--vltheme); }
    .svg-icon circle { stroke: var(--vltheme); stroke-width: 1; }
    .flex-container { display: flex; }
    .string { color:var(--string); }
    .key { color:var(--key); }
    .summary-table td .string { color: var(--vltheme); }
    .summary-table td { border-bottom: 1px solid var(--theme); width: 100%; padding:4px; }
    .summary-table tr td:first-child { font-weight: bold; width: auto; white-space: nowrap; padding-right: 20px; }
    .summary-table select { font-size: 1em;}
    .summary-table input[type=text] { width: 100%; width: -moz-available; width: -webkit-fill-available; }
    .summary-table input[type=number] { max-width: 60px;}
    .panel-option { font-size: 0.8em; }
    .number { color:var(--number); }
    .boolean { color:var(--boolean); }
    .null { color:var(--null); }
    .editable-list, .editable-list input, .editable-list textarea { vertical-align: top; width: 100%; width: -moz-available; width: -webkit-fill-available;}
    .editable-list td { padding: 5px;  }
    .editable-list th { text-align: left; }
    .pillbox { display: inline-block; border: 1px solid #ccc; border-radius: 20px; padding: 4px 6px; margin: 5px; }
    .pillbox span { background-color: var(--theme); border-radius: 10px; padding: 2px 4px; margin: 2px; }
    .section-header { font-size: 1.2em; font-weight: bold;}
    .notes { font-style: italic; font-size: 0.8em; }
    .summary-grid { display: flex; flex-wrap: wrap; font-size: 20px; color: var(--datatxt);} 
    .summary-grid > div { border: 1px solid var(--dtheme); background-color: var(--databg); align-self: flex-start; border-radius: 12px; margin: 5px; padding:5px; } 
    .summary-grid > div > div:first-child { color: var(--string); font-size: 16px;} 
    .tabcontent { display: none; border:1px solid var(--theme); border-radius: 0 20px 20px 20px; padding: 10px; margin-bottom: 10px; }
    .tablinks { font-size: 1em; color: var(--vltheme); background-color: var(--ltheme); cursor: pointer; padding: 10px 20px; margin: 0; border:none; border-radius: 12px 12px 0 0; }
    .tablinks.active { background-color: var(--vltheme); color: var(--theme); }
    .tooltip { position:absolute; background-color: black; color: white; padding: 5px; border-radius: 3px; z-index: 1000; }
    .copyable-item { cursor: pointer; background-color: var(--ltheme); font-weight: normal; border-radius: 8px; padding: 3px; }
    .copyable-item:hover { background-color: var(--theme); }
    #loading { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; color: #ffffff; background: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 10px; z-index: 1000; min-width: 300px; text-align: center; }
    #loading .spinner { margin: 10px auto; border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #ffffff; width: 30px; height: 30px; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .progress-container { width: 100%; height: 30px; background-color: #f3f3f3; border: 1px solid #ccc; border-radius: 5px; position: relative; margin: 20px 0; text-align: center; }
    .progress-bar { height: 100%; width: 0;  background-color: #4caf50; border-radius: 5px; position: absolute; top: 0; left: 0;  transition: width 0.2s ease-in-out; }
    .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: black; z-index: 2; }
    doro-doro { position: absolute; margin: -15px 0 0 10px; }
    .files-list { max-height: 400px; overflow-y: auto; border: 1px solid var(--theme); border-radius: 10px; padding: 10px; margin-top: 10px; }
    .file-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 2px 0; background-color: var(--ltheme); border-radius: 5px; cursor: pointer; }
    .file-item:hover { background-color: var(--theme); }
    .file-item.selected { background-color: var(--link); color: white; }
    .file-name { font-weight: bold; flex-grow: 1; }
    .file-size { font-size: 0.8em; color: var(--datatxt); margin-left: 10px; }
    .file-path { font-size: 0.7em; color: var(--datatxt); font-style: italic; }
    
    /* Modal styles */
    .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: var(--bg); margin: 5% auto; padding: 20px; border-radius: 10px; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto; }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .modal-title { font-size: 1.5em; font-weight: bold; color: var(--vltheme); }
    .close { color: var(--vltheme); font-size: 28px; font-weight: bold; cursor: pointer; }
    .close:hover { color: var(--error); }
    .modal-body { margin-bottom: 20px; }
    .modal-footer { display: flex; justify-content: flex-end; gap: 10px; }
    .modal textarea { width: 100%; height: 400px; font-family: monospace; font-size: 14px; }
    .modal button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
    .modal .btn-primary { background-color: var(--link); color: white; }
    .modal .btn-primary:hover { background-color: #3d8bf7; }
    .modal .btn-secondary { background-color: var(--ltheme); color: var(--vltheme); }
    .modal .btn-secondary:hover { background-color: var(--theme); }
  </style>
</head>
<body class="dark-theme">
  <div class="header">
    LoRA Metadata Viewer
    <doro-doro></doro-doro>
  </div>
  <hr/>
  <span id="settings-btn" class="collapsible boom" data-target="settings-panel">âš™</span>

  <div class="body-content">
    <div id="settings-panel" class="content">
      <div class="tab-container">
          <button class="tablinks" data-target-tab="tab0">General</button>
          <button class="tablinks" data-target-tab="tab1">Display</button>
          <button class="tablinks" data-target-tab="tab2">Summary</button>
          <button class="tablinks" data-target-tab="tab3">Metadata Editor</button>
          <button class="tablinks" data-target-tab="tab4">Custom Fields</button>
      
          <div id="tab0" class="tabcontent">
            <div><span class="notes">Settings are stored in your browser through the Local Storage API and will persist across sessions. Use this section to either reset, load, or save your current configuration.</span></div>           
            <button id="clearSettingsBtn" class="settings-button">Restore Default Settings</button>
            <button id="exportSettingsBtn" class="settings-button">Export Settings</button>
            <button id="importSettingsBtn" class="settings-button">Import Settings</button>
            <label class="custom-file-upload"><input type="file" id="importSettingsFile">Choose Import File</label>
            <span id="importSettingsFileName">No file chosen</span>
          </div>
          <div id="tab1" class="tabcontent">
            <div><input type="checkbox" id="enableSummary" class="settings-field" data-display="summaryPanel" checked><label for="enableSummary">Display Summary</label></div>
            <div><input type="checkbox" id="enableCivitAiInfo" class="settings-field" data-display="civitAiInfoPanel" checked><label for="enableCivitAiInfo">Display CivitAI Info</label></div>
            <div><input type="checkbox" id="enableSuggestedPrompt" class="settings-field" data-display="suggestedPromptPanel" checked><label for="enableSuggestedPrompt">Display Suggested Prompt</label></div>
            <div><input type="checkbox" id="enableTagFrequency" class="settings-field" data-display="tagFrequencyPanel" checked><label for="enableTagFrequency">Display Tag Frequency</label></div>
            <div><input type="checkbox" id="enableMetadata" class="settings-field" data-display="metadataPanel" checked><label for="enableMetadata">Display Metadata</label></div>
            <div><input type="checkbox" id="enableMetadataEditor" class="settings-field" data-display="metadataEditorPanel" checked><label for="enableMetadataEditor">Display Metadata Editor</label></div>
            <div><input type="checkbox" id="darkMode" class="settings-field" onclick="toggleDarkMode()" checked><label for="darkMode">Dark Mode</label></div>   
          </div>
          <div id="tab2" class="tabcontent">
            <div><input type="checkbox" id="showUndefinedSummaryValues" class="settings-field" checked><label class="section-header" for="showUndefinedSummaryValues">Show undefined summary values</label></div>
            <hr>
            <div><span class="section-header">Summary Fields</span><br><span class="notes">Specify the name of the fields to be displayed in the summary section, separated by commas. To include fields from the CivitAI metadata, add "civitai." prefix (ie. "civitai.trainedWords"). To include custom fields, add "custom." prefix (ie. "custom.training_time").</span></div>
            <textarea id="summaryFields" class="settings-field" rows="8" cols="100" spellcheck="false"></textarea>
            <hr>
            <div><span class="section-header">Custom Summary Template</span><br><span class="notes">This section defines the template to be used in the custom summary layout in HTML format. The fields to be displayed must be defined within {{}}. ( ie: {{ss_output_name}} ). To include file metadata fields, simply specify the field name. To include fields from the CivitAI metadata, add "civitai." prefix (ie. "civitai.trainedWords"). To include custom fields, add "custom." prefix (ie. "custom.training_time").</span></div>
            <textarea id="customTemplate" spellcheck="false" class="settings-field" rows="60" cols="100">
              <style>
                .tile { display: flex; flex-direction: column; margin: 10px; overflow-wrap: anywhere; } 
                .tile > div > div:first-child { border-bottom: 1px solid var(--vltheme); font-size: 0.8em; width: fit-content; } 
                .tile > div { padding: 5px; }
                .tile > div:first-child { border-bottom: 1px solid var(--vltheme); font-size: 1em; width: 100%; padding: 0; margin-bottom: 10px; } 
                .break { flex-basis: 100%; height: 0;}
                .prompt { font-size: 0.7em; }
              </style>
              <div class="custom-grid" style="display: flex; font-size: 20px;">
                <div class="tile" style="max-width: 320px; min-width: 320px;">
                  <div>Model</div>
                  <div>{{custom.civitai_link}}</div>
                  <div style="font-size: 0.8em;">{{custom.civitai_name?}}</div>
                  <div class="null">{{custom.preview}}</div>
                  <div style="max-height: 42px;">
                    <div>Creator</div>
                    <div>{{custom.creator}}</div>
                  </div>
                  <div>
                    <div>AutoV2</div>
                    <div>{{custom.autov2}}</div>
                  </div>
                  <div>
                    <div>AutoV3</div>
                    <div>{{custom.autov3}}</div>
                  </div>
                  <div>
                    <div>Base Model</div>
                    <div>{{custom.base_model_url}}</div>
                  </div>
                  <div>
                    <div>VAE</div>
                    <div>{{custom.vae_url}}</div>
                  </div>
                </div>
                <div class="custom-grid" style="display: flex; flex-wrap: wrap;">
                  <div class="tile">
                    <div>General</div>
                    <div>
                      <div>Batch</div>
                      <div>{{custom.batch_size}}</div>
                    </div>
                    <div>
                      <div>Gradient Acc. Steps</div>
                      <div>{{custom.gradient_accumulation}}</div>
                    </div>
                    <div>
                      <div>Resolution</div>
                      <div>{{custom.resolution}}</div>
                    </div>
                    <div>
                      <div>Clip Skip</div>
                      <div>{{ss_clip_skip}}</div>
                    </div>
                    <div>
                      <div>Epoch</div>
                      <div>{{ss_epoch}} of {{ss_num_epochs}}</div>
                    </div>
                    <div>
                      <div>Steps</div>
                      <div>{{ss_steps}} of {{ss_max_train_steps}}</div>
                    </div>
                  </div>
                  <div class="tile">
                    <div>Network</div>
                    <div>
                      <div>Module</div>
                      <div>{{ss_network_module}}</div>
                    </div>
                    <div>
                      <div>Algorithm</div>
                      <div>{{custom.algo_dora}}</div>
                    </div>
                    <div>
                      <div>Dim / Alpha</div>
                      <div class="number">{{ss_network_dim}} / {{ss_network_alpha}}</div>
                    </div>
                    <div>
                      <div>Conv Dim / Alpha</div>
                      <div class="number">{{custom.conv_dim}} / {{custom.conv_alpha}}</div>
                    </div>
                    <div>
                      <div>Network Dropout</div>
                      <div>{{ss_network_dropout}}</div>
                    </div>
                    <div>
                      <div>IP Noise Gamma</div>
                      <div>{{ss_ip_noise_gamma}}</div>
                    </div>
                  </div>
                  <div class="tile">
                    <div>Optimizer</div>
                    <div>
                      <div>Type</div>
                      <div>{{custom.optimizer}}</div>
                    </div>
                    <div>
                      <div>Scheduler</div>
                      <div>{{ss_lr_scheduler}}</div>
                    </div>
                    <div>
                      <div>Learning Rates</div>
                      <div>LR: {{ss_learning_rate}}</div>
                      <div>TE: {{ss_text_encoder_lr}}</div>
                      <div>UNET: {{ss_unet_lr}}</div>
                    </div>
                    <div>
                      <div>Optional Args</div>
                      <div style="font-size: 12px;">{{custom.optimizer_args}}</div>
                    </div>
                    <div>
                      <div>SNR</div>
                      <div>{{ss_min_snr_gamma}}</div>
                    </div>
                    <div>
                      <div>Warmup Steps</div>
                      <div>{{ss_lr_warmup_steps}}</div>
                    </div>
                  </div>
                  <div class="tile">
                    <div>Noise Offset</div>
                    <div>
                      <div>Noise Offset</div>
                      <div>{{ss_noise_offset}}</div>
                    </div>
                    <div>
                      <div>Pyramid Noise Iterations</div>
                      <div>{{ss_multires_noise_iterations}}</div>
                    </div>
                    <div>
                      <div>Discount</div>
                      <div>{{ss_multires_noise_discount}}</div>
                    </div>
                  </div>
                  <div class="tile">
                    <div>Training Info</div>
                    <div>
                      <div>Train Date</div>
                      <div>{{custom.training_date}}</div>
                    </div>
                    <div>
                      <div>Train Time</div>
                      <div>{{custom.training_time}}</div>
                    </div>
                    <div>
                      <div>Total Images</div>
                      <div>{{custom.training_images}}</div>
                    </div>
                    <div>
                      <div>Dataset</div>
                      <div style="font-size: 12px;">{{ss_dataset_dirs}}</div>
                    </div>
                  </div>
                  <div class="break"></div>
                  <div class="tile">
                    <div>Suggested Prompt</div>
                    <div id="dashboardSuggestedPrompt" class="prompt">{{custom.suggested_prompt?}}</div>
                  </div>
                  <div class="break"></div>
                  <div class="tile">
                    <div>Trigger Words (CivitAI)</div>
                    <div id="triggerWordsPrompt" class="prompt">{{civitai.trainedWords?}}</div>
                  </div>
                  <div class="break"></div>
                  <div class="tile" style="max-width: 100%;">
                    <div>Description (CivitAI)</div>
                    <div id="civitaiDescription" style="max-height: 300px; overflow-y: auto; font-size: 0.9em; line-height: 1.4;">{{custom.civitai_description?}}</div>
                  </div>
                </div>
              </div>
              
            </textarea>
          </div>
          <div id="tab4" class="tabcontent">
            <div><span class="section-header">Custom Fields</span><br><span class="notes">This section defines the list of custom fields that may be displayed in the summary section. Calculations are defined as javascript expressions. Data from the following are available for calculations: Safetensors File metadata (fileMetadata), CivitAI resource info (civitaiMetadata), and previously defined custom fields (customMetadata). Keep in mind that custom fields are created in the same order they are defined in the list, meaning you may use a custom field in a calculation only if it was defined in a previous row.</span></div>
            <table class="editable-list">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Calculation</th>
                  <th>&nbsp;</th>
                </tr>
              </thead>
              <tbody id="editableList" data-list-template="listItemTemplate"></tbody>
              <template id="listItemTemplate">
                <tr class="list-item">
                  <td><input name="label" type="text" class="label-input" placeholder="Enter label" spellcheck="false" value="{{label}}"></td>
                  <td><textarea name="calc" class="calculation-input" rows="3" cols="100" placeholder="Enter calculation" spellcheck="false" >{{calc}}</textarea></td>
                  <td><button class="settings-button" onclick="removeListItem(this)">X</button></td>
                </tr>
              </template>
            </table>
            <button class="settings-button" onclick="addListItem('editableList','listItemTemplate')">Add Custom Field</button>
            <button class="settings-button" onclick="document.getElementById('customFields').dispatchEvent(new Event('input', { bubbles: true, cancelable: true }))">Save Custom Field Changes</button>
            <textarea id="customFields" class="settings-field" style="display: none;" rows="12" spellcheck="false" data-editable-list="editableList"></textarea>      
          </div>
      </div>
    </div>

    <!-- Server Files Panel -->
    <div id="serverFilesPanel">
      <h3 class="collapsible expanded" data-target="server-files-content">Available Files</h3>
      <div id="server-files-content" class="content">
        <div class="panel-option">
          <button id="refreshFilesBtn" class="settings-button">Refresh File List</button>
          <span id="serverInfo" class="notes"></span>
        </div>
        <div class="notes" style="margin: 10px 0; padding: 8px; background-color: var(--vdtheme); border-radius: 5px;">
          âš¡ <strong>Fast Loading:</strong> Metadata is extracted on the server for .safetensors files, avoiding large downloads. Only metadata is transferred, making loading much faster!
        </div>
        <div class="panel-option" style="margin: 10px 0;">
          <input type="text" id="fileSearchInput" placeholder="ðŸ” Search files by name... (Ctrl+F)" style="width: 100%; padding: 8px; margin-bottom: 5px; border: 1px solid var(--theme);">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="fileSearchStats" class="notes"></span>
            <button id="clearSearchBtn" class="settings-button" style="font-size: 0.9em; padding: 4px 8px; display: none;" title="Clear search (Esc)">âœ– Clear</button>
          </div>
        </div>
        <div id="filesList" class="files-list"></div>
      </div>
    </div>

    <div id="notificationPanel"></div>

    <div id="summaryPanel">
      <h3 class="collapsible expanded">Summary</h3>
      <div class="content">
        <div class="panel-option">
          <label class="section-header" for="summaryFormat">Layout: </label>
          <select id="summaryFormat" class="settings-field" data-select-toggle>
            <option value="json">JSON</option>
            <option value="table">Table</option>
            <!-- <option value="grid">Grid</option> -->
            <option value="custom" selected>Dashboard</option>
          </select>
        </div>
        <div id="summaryJson" data-toggle-target="summaryFormat" data-toggle-value="json">
          <button class="copy-btn" onclick="copyToClipboard('summary',event)">Copy to clipboard</button>
          <pre id="summary" class="json-data"></pre>
        </div>
        <div id="summaryTable" data-toggle-target="summaryFormat" data-toggle-value="table" class="summary-table"></div>
        <div id="summaryGrid" data-toggle-target="summaryFormat" data-toggle-value="grid"></div>
        <div id="summaryCustom" data-toggle-target="summaryFormat" data-toggle-value="custom"></div>
        <hr>
      </div>
      <template id="summaryGridTemplate">
        <div>
          <div>{{key}}</div>
          <div>{{value}}</div>
        </div>
      </template>
    </div>

    <div id="suggestedPromptPanel">
      <h3 class="collapsible" data-target="suggested-prompt-content">Suggested Prompt</h3>
      <div id="suggested-prompt-content" class="content">
        <div id="tag-filter-btn" class="collapsible" data-target="suggested-prompt-settings">âš™</div>
        <div id="suggested-prompt-settings" >
          <table class="summary-table">
            <tr>
              <td><label for="suggestedPromptCount"><span >Show top N tags</span></label> <span id="suggestedPromptFilterVld" class="error"></span></td>
              <td colspan="2"><input type="number" id="suggestedPromptCount" class="settings-field"><span class="note"></span></td>
            </tr>
            <tr>
              <td><label for="suggestedPromptFilter"><span>Include Filter</span></label></td>
              <td>
                <input type="text" id="suggestedPromptFilter" class="settings-field">
              </td>
              <td>
                <select id="suggestedPromptFilterMethod" class="settings-field">
                  <option selected>None/Disable</option>
                  <option value="partial">Partial Match (comma delimited)</option>
                  <option value="exact">Exact Match (comma delimited)</option>
                  <option value="regex">Regular Expression</option>
                </select>
              </td>
            </tr>
            <tr>
              <td><label for="suggestedPromptExcludeFilter"><span >Exclude Filter</span></label> <span id="suggestedPromptExcludeFilterVld" class="error"></span></td>
              <td>
                <input type="text" id="suggestedPromptExcludeFilter" class="settings-field">
              </td>
              <td>
                <select id="suggestedPromptExcludeFilterMethod" class="settings-field">
                  <option>None/Disable</option>
                  <option value="partial">Partial Match (comma delimited)</option>
                  <option value="exact" selected>Exact Match (comma delimited)</option>
                  <option value="regex">Regular Expression</option>
                </select>
              </td>
            </tr>
            <tr>
              <td colspan="3"><input type="checkbox" id="suggestedPromptByFolder" class="settings-field"><label for="suggestedPromptByFolder">Show prompt by folder</label></td>
            </tr>
          </table>
        </div>
        <div id="suggestedPromptDetails"></div>
      </div>
    </div>

    <div id="tagFrequencyPanel" >
      <h3 class="collapsible" data-target="tag-frequency-content">Tag Frequency</h3>
      <div id="tag-frequency-content" class="content">
        <div id="tag-filter-btn" class="collapsible" data-target="tag-frequency-settings">âš™</div>
        <div id="tag-frequency-settings" >
          <table class="summary-table">
            <tr>
              <td><label for="tagFrequencyCount"><span >Show top N tags</span></label> <span id="tagFrequencyFilterVld" class="error"></span></td>
              <td colspan="2"><input type="number" id="tagFrequencyCount" class="settings-field"><span class="note"></span></td>
            </tr>
            <tr>
              <td><label for="tagFrequencyFilter"><span>Include Filter</span></label></td>
              <td>
                <input type="text" id="tagFrequencyFilter" class="settings-field">
              </td>
              <td>
                <select id="tagFrequencyFilterMethod" class="settings-field">
                  <option selected>None/Disable</option>
                  <option value="partial">Partial Match (comma delimited)</option>
                  <option value="exact">Exact Match (comma delimited)</option>
                  <option value="regex">Regular Expression</option>
                </select>
              </td>
            </tr>
            <tr>
              <td><label for="tagExcludeFilter"><span >Exclude Filter</span></label> <span id="tagExcludeFilterVld" class="error"></span></td>
              <td>
                <input type="text" id="tagExcludeFilter" class="settings-field">
              </td>
              <td>
                <select id="tagExcludeFilterMethod" class="settings-field">
                  <option selected>None/Disable</option>
                  <option value="partial">Partial Match (comma delimited)</option>
                  <option value="exact">Exact Match (comma delimited)</option>
                  <option value="regex">Regular Expression</option>
                </select>
              </td>
            </tr>
            <tr>
              <td colspan="3"><input type="checkbox" id="tagByFolder" class="settings-field"><label for="tagByFolder">Show tags by folder</label></td>
            </tr>
          </table>
        </div>
        <button class="copy-btn" onclick="copyToClipboard('keywordDetails',event)">Copy to clipboard</button>
        <pre id="keywordDetails" class="json-data"></pre>
      </div>
    </div>

    <div id="civitAiInfoPanel">
      <h3 class="collapsible">CivitAI Info</h3>
      <div class="content summary-table">
        <table>
          <tr><td>Model URL:</td><td><a id="modelUrl" target='_blank' href="#"></a></td></tr>
          <tr><td>Resource Info:</td><td><a id="resourceUrl" target='_blank' href="#"></a></td></tr>
          <tr><td>Preview:</td><td><img id='previewImage' src='' /></td></tr>
        </table>
        <div><pre id="civitaiDisplay" class="json-data"></div>
      </div>
    </div>

    <div id="metadataPanel">
      <h3 class="collapsible">Metadata</h3>
      <div class="content">
        <button class="copy-btn" onclick="copyToClipboard('metadataDisplay',event)">Copy to clipboard</button>
        <button class="copy-btn" onclick="openEditModal()" style="right: 80px;">Edit JSON</button>
        <pre id="metadataDisplay" class="json-data"></pre>
      </div>
    </div>

    <div id="metadataEditorPanel">
      <h3 class="collapsible">Metadata Editor</h3>
      <div class="content">
        <div id="editorHeader" class="editor-header">
          <button onclick="saveMetadataFromEditor()">Save Changes</button>
        </div>
        <div id="editorNotificationPanel"></div>
        <textarea id="metadataEditor" spellcheck="false" rows="100" cols="100"></textarea>
      </div>
    </div>
  </div>

  <hr/>
  <div class="footer">
    LoRA Metadata Viewer v1.6 |
    <a href="https://github.com/Xypher7/lora-metadata-viewer" target='_blank'>GitHub</a> |
    <a href="https://civitai.com/models/249721" target='_blank'>CivitAI</a>
  </div>

  <!-- Edit Metadata Modal -->
  <div id="editModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Edit Metadata JSON</h2>
        <span class="close" onclick="closeEditModal()">&times;</span>
      </div>
      <div class="modal-body">
        <textarea id="editMetadataTextarea" placeholder="Enter JSON metadata here..."></textarea>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
        <button class="btn-primary" onclick="saveMetadata()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Loading Animation Div -->
  <div id="loading">
    <div class="loading-message"></div>
    <div class="spinner"></div>
    <div class="progress-container">
      <div class="progress-bar"></div>
      <div class="progress-text">0%</div> <!-- Text placed as a sibling to the progress-bar -->
    </div>
  </div>

  <script src="https://xypher7.github.io/Doro.js/doro.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4/dist/sha256.umd.min.js"></script>
  <script>
    //#region Gobal Variables
    let safetensorsFile;
    let fileMetadata = {};
    let civitaiMetadata = {};
    let customMetadata = {};
    let basemodelMetadata = {};
    let vaeMetadata = {};

    const defaults = {};
    defaults.summaryFields = "ss_output_name,ss_sd_model_name,ss_network_module,custom.batch_size,ss_gradient_accumulation_steps,custom.resolution,ss_optimizer,ss_lr_scheduler,ss_network_module,ss_clip_skip,ss_network_dim,ss_network_alpha,ss_network_args,ss_epoch,ss_num_epochs,ss_steps,ss_max_train_steps,ss_learning_rate,ss_text_encoder_lr,ss_unet_lr,ss_noise_offset,ss_adaptive_noise_scale,ss_min_snr_gamma,sshs_model_hash,custom.training_time,custom.training_start_time,custom.training_end_time,custom.lora_hash,custom.lora_hash_type,custom.civitai_url,ss_dataset_dirs,civitai.trainedWords";
    defaults.suggestedPromptCount = 10;
    defaults.suggestedPromptExcludeFilter = "1girl,1boy,background,standing,portrait,cowboy shot,upper body,looking at viewer,solo,smile,open mouth,closed mouth,blush,nude,nipples,anime,male focus";
    defaults.suggestedPromptExcludeFilterMethod = 'partial';
    defaults.suggestedPromptByFolder = "true";
    defaults.customFields = [
      {"label":"training_start_time","calc":"new Date(fileMetadata.ss_training_started_at * 1000)"},
      {"label":"training_end_time","calc":"new Date(fileMetadata.ss_training_finished_at * 1000)"},
      {"label":"training_time_ms","calc":"Math.abs(customMetadata.training_end_time.getTime() - customMetadata.training_start_time.getTime())"},
      {"label":"training_h","calc":"Math.floor(customMetadata.training_time_ms / (1000 * 60 * 60))"},
      {"label":"training_m","calc":"Math.floor((customMetadata.training_time_ms % (1000 * 60 * 60)) / (1000 * 60))"},
      {"label":"training_s","calc":"Math.floor((customMetadata.training_time_ms % (1000 * 60)) / 1000)"},
      {"label":"training_time","calc":"customMetadata.training_time_ms ? `${customMetadata.training_h}h ${customMetadata.training_m}m ${customMetadata.training_s}s` : undefined"},
      {"label":"batch_size","calc":"fileMetadata.ss_total_batch_size || (fileMetadata.ss_datasets && fileMetadata.ss_datasets[0].batch_size_per_device)"},
      {"label":"resolution","calc":"fileMetadata['modelspec.resolution'] || fileMetadata.ss_resolution || fileMetadata.ss_datasets[0].resolution.toString()"},
      {"label":"optimizer","calc":"fileMetadata.ss_optimizer && fileMetadata.ss_optimizer.match(/\\b(\\w+)\\b(?=\\s*\\()|\\b(\\w+)\\b$/)?.[0]"},
      {"label":"civitai_url","calc":"civitaiMetadata?.modelId ? `https://civitai.com/models/${civitaiMetadata.modelId}?modelVersionId=${civitaiMetadata.id}` : null"},
      {"label":"civitai_link","calc":"customMetadata.civitai_url ? `<a target='_blank' href='${customMetadata.civitai_url}'>${fileMetadata.ss_output_name || safetensorsFile.name}</a>` : fileMetadata.ss_output_name || safetensorsFile.name"},
      {"label":"preview","calc":"(civitaiMetadata?.images && customMetadata.civitai_url) ? `<a target='_blank' href='${customMetadata.civitai_url}'><img src='${civitaiMetadata.images[0].url}' style='max-width: 100%;'></a>` : ``"},
      {"label":"base_model_hash","calc":"(fileMetadata.ss_new_sd_model_hash || fileMetadata.ss_sd_model_hash).substring(0,10)"},
      {"label":"base_model_url","calc":"basemodelMetadata?.modelId ? `<a target='_blank' href='https://civitai.com/models/${basemodelMetadata.modelId}?modelVersionId=${basemodelMetadata.id}'>${fileMetadata.ss_sd_model_name} (${basemodelMetadata.baseModel || civitaiMetadata.baseModel})</a>` : (fileMetadata.ss_sd_model_name.indexOf('/')>0 ? `<a target='_blank' href='https://huggingface.co/${fileMetadata.ss_sd_model_name}'>${fileMetadata.ss_sd_model_name}</a>` : fileMetadata.ss_sd_model_name)"},
      {"label":"vae_url","calc":"vaeMetadata?.modelId ? `<a target='_blank' href='https://civitai.com/models/${vaeMetadata.modelId}?modelVersionId=${vaeMetadata.id}'>${fileMetadata.ss_vae_name}</a>` : (fileMetadata.ss_vae_name.indexOf('/')>0 ? `<a target='_blank' href='https://huggingface.co/${fileMetadata.ss_vae_name}'>${fileMetadata.ss_vae_name}</a>` : fileMetadata.ss_vae_name)"},
      {"label":"conv_dim","calc":"parseInt(fileMetadata.ss_network_args.conv_dim) || undefined"},
      {"label":"conv_alpha","calc":"parseFloat(fileMetadata.ss_network_args.conv_alpha) || undefined"},
      {"label":"algo","calc":"fileMetadata.ss_network_args.algo"},
      {"label":"optional_args","calc":"fileMetadata.ss_optimizer.indexOf('(') > 0 ? fileMetadata.ss_optimizer.slice(fileMetadata.ss_optimizer.indexOf('(')+1,-1) : undefined"},
      {"label":"optimizer_args","calc":"Object.fromEntries(customMetadata.optional_args.replace('[','(').replace(']',')').match(/(\\w+=[^,()]+|\\w+=\\([^()]*\\))/g).map(item => item.split('=')))"},
      {"label":"weight_decay","calc":"customMetadata.optimizer_args.weight_decay"},
      {"label":"betas","calc":"customMetadata.optimizer_args.betas"},
      {"label":"d_coef","calc":"customMetadata.optimizer_args.d_coef"},
      {"label":"dora","calc":"fileMetadata.ss_network_args.dora_wd.toLowerCase() === 'true'"},
      {"label":"algo_dora","calc":"customMetadata.algo && customMetadata.dora ? `${customMetadata.algo} (${customMetadata.dora && 'DoRA'})` : customMetadata.algo || customMetadata.dora"},
      {"label":"training_images","calc":"Object.values(fileMetadata.ss_dataset_dirs).reduce((sum, obj) => sum + obj.img_count, 0)"},
      {"label":"training_date","calc":"fileMetadata.ss_training_started_at ? customMetadata.training_start_time.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : undefined"},
      {"label":"gradient_accumulation","calc":"fileMetadata.ss_gradient_checkpointing === 'True' ? fileMetadata.ss_gradient_accumulation_steps : undefined"},
      {"label":"file_hash","calc":"customMetadata?.lora_hash.toUpperCase() + (customMetadata?.lora_hash_type?` (${customMetadata?.lora_hash_type})`:'')"},
      {"label":"creator","calc":"civitaiMetadata?.model ? `<a href='https://civitai.com/user/${civitaiMetadata?.model?.creator.username}' target='_blank'><span>${civitaiMetadata?.model?.creator.username}</span><img alt='' src='${civitaiMetadata?.model?.creator.image}' style='border-radius: 50%; float:right; width:80px; margin-top:-20px;'></img></a>`: undefined"},
      {"label":"civitai_name","calc":"customMetadata.civitai_url ? `<a target='_blank' href='${customMetadata.civitai_url}'>${civitaiMetadata?.model?.name}</a>` : undefined"},
      {"label":"civitai_description","calc":"civitaiMetadata?.description || undefined"},
    ];
    
    const metadataDisplay = document.getElementById('metadataDisplay');
    const metadataEditor = document.getElementById('metadataEditor');
    const metadataEditorSimple = document.getElementById('metadataEditorSimple');
    const summary = document.getElementById('summary'); 
    const summaryTable = document.getElementById('summaryTable'); 
    const summaryGrid = document.getElementById('summaryGrid'); 
    const summaryGridTemplate = document.getElementById('summaryGridTemplate'); 
    const summaryCustom = document.getElementById('summaryCustom'); 
    const modelUrl = document.getElementById('modelUrl');
    const resourceUrl = document.getElementById('resourceUrl');
    const civitaiDisplay = document.getElementById('civitaiDisplay');
    const previewImage = document.getElementById('previewImage');
    const keywordDetails = document.getElementById('keywordDetails');
    const suggestedPromptDetails = document.getElementById('suggestedPromptDetails');
    const notificationPanel = document.getElementById('notificationPanel');
    const editorNotificationPanel = document.getElementById('editorNotificationPanel');
    const editorHeader = document.getElementById('editorHeader');
    
    const summaryFields = document.getElementById('summaryFields');
    const showUndefinedSummaryValues = document.getElementById('showUndefinedSummaryValues');
    const customFields = document.getElementById('customFields');
    const customTemplate = document.getElementById('customTemplate');
    const enableSummary = document.getElementById('enableSummary');
    const enableCivitAiInfo = document.getElementById('enableCivitAiInfo');
    const enableTagFrequency = document.getElementById('enableTagFrequency');
    const enableSuggestedPrompt = document.getElementById('enableSuggestedPrompt');
    const tagFrequencyCount = document.getElementById('tagFrequencyCount');
    const tagFrequencyFilter = document.getElementById('tagFrequencyFilter');
    const tagFrequencyFilterVld = document.getElementById('tagFrequencyFilterVld');
    const tagFrequencyFilterMethod = document.getElementById('tagFrequencyFilterMethod');
    const tagByFolder = document.getElementById('tagByFolder');
    const tagExcludeFilter = document.getElementById('tagExcludeFilter');
    const tagExcludeFilterMethod = document.getElementById('tagExcludeFilterMethod');
    const tagExcludeFilterVld = document.getElementById('tagExcludeFilterVld');
    const suggestedPromptCount = document.getElementById('suggestedPromptCount');
    const suggestedPromptFilter = document.getElementById('suggestedPromptFilter');
    const suggestedPromptFilterVld = document.getElementById('suggestedPromptFilterVld');
    const suggestedPromptFilterMethod = document.getElementById('suggestedPromptFilterMethod');
    const suggestedPromptByFolder = document.getElementById('suggestedPromptByFolder');
    const suggestedPromptExcludeFilter = document.getElementById('suggestedPromptExcludeFilter');
    const suggestedPromptExcludeFilterMethod = document.getElementById('suggestedPromptExcludeFilterMethod');
    const suggestedPromptExcludeFilterVld = document.getElementById('suggestedPromptExcludeFilterVld');

    const pillboxTemplate = document.getElementById('pillboxTemplate');
    const enableMetadata = document.getElementById('enableMetadata');
    const enableMetadataEditor = document.getElementById('enableMetadataEditor');
    const darkMode = document.getElementById('darkMode');
    const clearSettingsBtn = document.getElementById('clearSettingsBtn');
    const exportSettingsBtn = document.getElementById('exportSettingsBtn');
    const importSettingsBtn = document.getElementById('importSettingsBtn');
    const importSettingsFile = document.getElementById('importSettingsFile');
    const importSettingsFileName = document.getElementById('importSettingsFileName');

    const loading = document.getElementById('loading');
    const loadingMessage = document.querySelector('.loading-message');
    const progressBar = document.querySelector('.progress-bar');
    const progressText = document.querySelector('.progress-text');
    
    // Server-related elements
    const serverFilesPanel = document.getElementById('serverFilesPanel');
    const filesList = document.getElementById('filesList');
    const refreshFilesBtn = document.getElementById('refreshFilesBtn');
    const serverInfo = document.getElementById('serverInfo');
    const fileSearchInput = document.getElementById('fileSearchInput');
    const fileSearchStats = document.getElementById('fileSearchStats');
    const clearSearchBtn = document.getElementById('clearSearchBtn');
    
    // Server state
    let serverFiles = [];
    let filteredFiles = [];
    let selectedFileItem = null;
    let isServerMode = false;
    //#endregion Global Variables
    //#region Initialization 
    init();

    function init(){   
      initSelectToggle();
      initSettingsStorage();
      initCollapsible();
      initTabs();
      initServerMode();
      [tagFrequencyCount, tagFrequencyFilter, tagExcludeFilter, tagExcludeFilterMethod, tagFrequencyFilterMethod].forEach(e=>{ e.addEventListener('change', updateTagFrequency); });
      tagByFolder.addEventListener('click', updateTagFrequency);
      [suggestedPromptCount, suggestedPromptFilter, suggestedPromptExcludeFilter, suggestedPromptExcludeFilterMethod, suggestedPromptFilterMethod].forEach(e=>{ e.addEventListener('change', ()=>{updateTagFrequency(null,true);}); });
      suggestedPromptByFolder.addEventListener('click', ()=>{updateTagFrequency(null,true);});
      if(window.matchMedia && !window.matchMedia('(prefers-color-scheme: dark)').matches) darkMode.checked = !darkMode.checked;
    }

    function initSelectToggle() {
      document.querySelectorAll('select[data-select-toggle]').forEach(select => {
          select.addEventListener('change', () => {
              document.querySelectorAll(`[data-toggle-target="${select.id}"]`).forEach(element => {
                  element.style.display = select.value === element.getAttribute('data-toggle-value') ? 'block' : 'none';
              });
          });
          select.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));    
      });
    }

    function initCollapsible(){
      document.querySelectorAll('.collapsible').forEach((collapsible, i) => {
        collapsible.addEventListener('click', function () {
          this.classList.toggle('active');
          const targetSelector = this.getAttribute('data-target');
          const content = !targetSelector ? this.nextElementSibling : document.getElementById(targetSelector);
          if (content.style.display === 'block') {
            content.style.display = 'none';
          } else {
            content.style.display = 'block';
          }
        });
        const targetSelector = collapsible.getAttribute('data-target');
        if(!!targetSelector) {
          const content = document.getElementById(targetSelector);
          content.classList.add('content');
        }
        if (collapsible.classList.contains('expanded')) collapsible.click();
      });

      const toggleDisplay = e => {      
        const targetId = e.getAttribute('data-display');
        const targetElement = document.getElementById(targetId);
        if (targetElement) {
          targetElement.style.display = e.checked ? 'block' : 'none';
        }
      };

      // Panel display toggle
      document.querySelectorAll('input[type="checkbox"][data-display]').forEach(function(checkbox) {
        checkbox.addEventListener('click', function() { toggleDisplay(this); });
        window.addEventListener('load', ()=>{ toggleDisplay(checkbox); });
      });
    }

    function initTabs(){
      document.querySelectorAll(".tab-container").forEach(container => {
          const tablinks = container.querySelectorAll("[data-target-tab]");
          tablinks.forEach(button => { // Loop through each tab button and add a click event listener
              button.addEventListener("click", () => {
                  container.querySelectorAll(".tabcontent").forEach(tab => { tab.style.display = "none"; }); // Hide all tab content within this tab container
                  tablinks.forEach(tab => { tab.classList.remove("active"); }); // Remove "active" class from all tab buttons within this tab container
                  const targetTabId = button.getAttribute("data-target-tab");
                  container.querySelector("#"+targetTabId).style.display = "block"; // Show the selected tab content within this tab container
                  button.classList.add("active"); // Add "active" class to the clicked tab button within this tab container
              });
          });
          // Set the default tab to be opened within this tab container
          container.querySelector(".tabcontent").style.display = "block";
          container.querySelector("[data-target-tab]").classList.add("active");
      });
    }

    function initServerMode() {
      // Check if we're running in server mode by trying to fetch server info
      fetch('/api/info')
        .then(response => response.json())
        .then(data => {
          if (data.server_mode) {
            isServerMode = true;
            serverInfo.textContent = `Server directory: ${data.files_directory}`;
            loadServerFiles();
            serverFilesPanel.style.display = 'block';
          } else {
            serverFilesPanel.style.display = 'none';
          }
        })
        .catch(error => {
          // Not in server mode or server not available
          serverFilesPanel.style.display = 'none';
          isServerMode = false;
        });
      
      // Add event listeners for server UI
      refreshFilesBtn.addEventListener('click', loadServerFiles);
      fileSearchInput.addEventListener('input', filterFiles);
      clearSearchBtn.addEventListener('click', clearSearch);
    }

    async function loadServerFiles() {
      try {
        showLoading('Loading file list...');
        const response = await fetch('/api/files');
        const data = await response.json();
        
        if (response.ok) {
          serverFiles = data.files;
          filteredFiles = serverFiles; // Initialize filtered list
          renderFilesList();
          updateSearchStats();
          serverInfo.textContent = `Found ${data.total} files in: ${data.directory}`;
        } else {
          serverInfo.textContent = `Error: ${data.error}`;
          filesList.innerHTML = '<div class="error">Failed to load files</div>';
        }
      } catch (error) {
        serverInfo.textContent = 'Error connecting to server';
        filesList.innerHTML = '<div class="error">Failed to connect to server</div>';
      } finally {
        hideLoading();
      }
    }

    function renderFilesList() {
      if (filteredFiles.length === 0) {
        if (serverFiles.length === 0) {
          filesList.innerHTML = '<div class="notes">No compatible files found</div>';
        } else {
          filesList.innerHTML = '<div class="notes">No files match your search</div>';
        }
        return;
      }

      const searchTerm = fileSearchInput.value.toLowerCase().trim();
      
      const filesHtml = filteredFiles.map(file => {
        const sizeText = formatFileSize(file.size);
        const pathText = file.relative_path !== file.name ? file.relative_path : '';
        
        // Highlight search matches
        let displayName = file.name;
        let displayPath = pathText;
        
        if (searchTerm) {
          const highlightText = (text, term) => {
            if (!text || !term) return text;
            const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark style="background-color: var(--link); color: white; padding: 1px 2px; border-radius: 2px;">$1</mark>');
          };
          
          displayName = highlightText(file.name, searchTerm);
          displayPath = highlightText(pathText, searchTerm);
        }
        
        return `
          <div class="file-item" data-file-path="${file.relative_path}">
            <div>
              <div class="file-name">${displayName}</div>
              ${displayPath ? `<div class="file-path">${displayPath}</div>` : ''}
            </div>
            <div class="file-size">${sizeText}</div>
          </div>
        `;
      }).join('');

      filesList.innerHTML = filesHtml;

      // Add click handlers to file items
      filesList.querySelectorAll('.file-item').forEach(item => {
        item.addEventListener('click', () => {
          // Remove previous selection
          if (selectedFileItem) {
            selectedFileItem.classList.remove('selected');
          }
          
          // Select current item
          item.classList.add('selected');
          selectedFileItem = item;
          
          // Load the file
          const filePath = item.getAttribute('data-file-path');
          loadServerFile(filePath);
        });
      });
    }

    async function loadServerFile(filePath) {
      clearAll();
      try {
        // Check if it's a safetensors file and we're in server mode
        if (filePath.toLowerCase().endsWith('.safetensors')) {
          showLoading('Loading metadata from server...');
          
          // Fetch metadata directly from server
          const metadataResponse = await fetch(`/api/metadata/${encodeURIComponent(filePath)}`);
          
          if (metadataResponse.ok) {
            const metadataResult = await metadataResponse.json();
            
            // Create a mock file object for compatibility
            const fileName = filePath.split('/').pop();
            safetensorsFile = {
              name: fileName,
              serverPath: filePath,
              relative_path: filePath, // Set the relative path for saving
              size: metadataResult.file_info?.size || 0,
              type: 'application/octet-stream',
              isServerFile: true
            };
            
            updateLoading('Processing metadata...', 50);
            
            // Process the metadata directly
            fileMetadata = metadataResult.metadata;
            updateMetadataEditor(metadataResult.formatted_metadata);
            
            updateLoading('Processing custom fields...', 70);
            setCustomMetadata();
            
            updateMetadata(metadataResult.metadata);
            updateTagFrequency(metadataResult.metadata);
            updateTagFrequency(metadataResult.metadata, true);
            updateSummary(metadataResult.metadata, civitaiMetadata, customMetadata);
            
            // Pass hashes from server for CivitAI lookup
            if (metadataResult.hashes) {
              safetensorsFile.serverHashes = metadataResult.hashes;
            }
            updateCivitAiInfo(safetensorsFile);
            
            hideLoading();
            notificationPanel.innerHTML = `Loaded metadata for: ${fileName}`;
            return;
          } else {
            // If metadata extraction fails, fall back to downloading the entire file
            const errorData = await metadataResponse.json().catch(() => ({}));
            console.warn('Server metadata extraction failed:', errorData.error);
            notificationPanel.innerHTML = 'Server metadata extraction failed, downloading file...';
          }
        }
        
        // Fall back to downloading the entire file (for .gguf files or if metadata extraction failed)
        showLoading('Downloading file...');
        
        const response = await fetch(`/api/file/${encodeURIComponent(filePath)}`);
        
        if (response.ok) {
          const contentLength = response.headers.get('Content-Length');
          const total = parseInt(contentLength, 10);
          let loaded = 0;
          
          const reader = response.body.getReader();
          const stream = new ReadableStream({
            start(controller) {
              function pump() {
                return reader.read().then(({ done, value }) => {
                  if (done) {
                    controller.close();
                    return;
                  }
                  
                  loaded += value.byteLength;
                  if (total) {
                    const progress = Math.round((loaded / total) * 20); // Use 20% for download
                    updateLoading(`Downloading... ${formatFileSize(loaded)}/${formatFileSize(total)}`, progress);
                  }
                  
                  controller.enqueue(value);
                  return pump();
                });
              }
              return pump();
            }
          });
          
          // Convert stream to blob
          const streamResponse = new Response(stream);
          const blob = await streamResponse.blob();
          
          updateLoading('File downloaded, processing...', 25);
          
          // Create a File object from the blob
          const file = new File([blob], filePath.split('/').pop(), {
            type: 'application/octet-stream'
          });
          
          // Set the file name for display
          safetensorsFile = file;
          safetensorsFile.serverPath = filePath;
          safetensorsFile.relative_path = filePath; // Set the relative path for saving
          
          // Process the file using existing handleFile logic
          // Don't hide loading here - let handleFileData manage the loading state
          await handleFileData(file);
        } else {
          let errorData;
          try {
            errorData = await response.json();
          } catch (e) {
            errorData = { error: `HTTP ${response.status}: ${response.statusText}` };
          }
          notificationPanel.innerHTML = `Error loading file: ${errorData.error}`;
          hideLoading();
        }
      } catch (error) {
        console.error('File loading error:', error);
        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
          notificationPanel.innerHTML = `Network error loading file. This might be due to the file size or proxy settings.`;
        } else {
          notificationPanel.innerHTML = `Error loading file: ${error.message}`;
        }
        hideLoading();
      }
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async function handleFile(file) {
      clearAll();
      safetensorsFile = file;
      await handleFileData(file);
    }

    async function handleFileData(file) {
      if(file.name.endsWith('.gguf')) {
        updateCivitAiInfo(file);
        setCustomMetadata();
        return;
      }
      if (!file.name.endsWith('.safetensors')) {
        notificationPanel.innerHTML = 'Please drop a valid .safetensors file.';
        hideLoading();
        return;
      }
      try {
        updateLoading('Parsing metadata...', 27);
        const arrayBuffer = await file.slice(0, 8).arrayBuffer(); // Read first 8 bytes
        const metadataSize = new DataView(arrayBuffer).getUint32(0, true); // Extract metadata size
        const metadataArrayBuffer = await file.slice(8, 8 + metadataSize).arrayBuffer(); // Read metadata chunk
        const header = JSON.parse(new TextDecoder('utf-8').decode(new Uint8Array(metadataArrayBuffer))); // Decode and parse metadata

        let formattedMetadata = header['__metadata__'] || ''; 
        let metadata = {};
        if (!formattedMetadata) {
          notificationPanel.innerHTML = 'No metadata found';
          hideLoading();
          return;
        } else {
          for (const key in formattedMetadata) {
            if (typeof formattedMetadata[key] === 'string') {
              try {
                metadata[key] = JSON.parse(formattedMetadata[key]);
              } catch (error) {
                metadata[key] = formattedMetadata[key];
              }
            } else {
              metadata[key] = formattedMetadata[key];
            }
          }
        }
        
        updateLoading('Setting up metadata...', 28);
        fileMetadata = metadata;
        updateMetadataEditor(formattedMetadata);
        
        updateLoading('Processing custom fields...', 29);
        setCustomMetadata();
        
        updateMetadata(metadata);
        updateTagFrequency(metadata);
        updateTagFrequency(metadata,true);
        updateSummary(metadata, civitaiMetadata, customMetadata);
        updateCivitAiInfo(file);
      } catch (error) {
        notificationPanel.innerHTML += 'Error parsing metadata.<br>';
        console.error('Error reading file:', error);
        hideLoading();
      }
    }


    function initSettingsStorage(){
      // Unique prefix for the app
      const appPrefix = 'x_lmv.';

      // Retrieve values from local storage and set default values if not present
      const loadSettings = () => {
          document.querySelectorAll('.settings-field').forEach(function (element) {
              const id = element.id ? appPrefix + element.id : null;
              if (id) {
                  let value = localStorage.getItem(id);
                  if (value === null && defaults[element.id] !== undefined) {
                      value = typeof defaults[element.id] === 'object' ? JSON.stringify(defaults[element.id]) : defaults[element.id];
                      localStorage.setItem(id, value); // Store default value in local storage
                  }
                  if (value !== null) {
                      if (element.type === 'checkbox') {
                          element.checked = value === 'true';
                      } else {
                          element.value = value;
                          if(element.getAttribute('data-editable-list') !== null){
                              const listElem = document.getElementById(element.getAttribute('data-editable-list'));
                              JSON.parse(value).forEach(obj => {
                                  addListItem(element.getAttribute('data-editable-list'), listElem.getAttribute('data-list-template'), obj);
                              })
                          }
                          if (element.tagName.toLowerCase() === 'select')
                              element.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));                       
                      }
                      element.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                  }
              }
          });
          !darkMode.checked && toggleDarkMode();
      };

      // Save values to local storage
      const saveSettings = () => {
          document.querySelectorAll('.settings-field').forEach(function (element) {
              const id = element.id ? appPrefix + element.id : null;
              if (id) {
                  let value = element.type === 'checkbox' ? element.checked : element.value;
                  if(element.getAttribute('data-editable-list') !== null){
                      const objectArray = [];
                      const listElem = document.getElementById(element.getAttribute('data-editable-list'));
                      listElem.querySelectorAll('.list-item').forEach(listItem => {
                          const itemObject = {};
                          listItem.querySelectorAll('[name]').forEach(inputField => {
                              itemObject[inputField.getAttribute('name')] = inputField.value;
                          });
                          objectArray.push(itemObject);
                      });
                      value = element.value = JSON.stringify(objectArray);
                  }
                  localStorage.setItem(id, value.toString());
              }
          });
      }

      const exportLocalStorage = () => {
          const storageData = JSON.stringify(localStorage); // Convert localStorage to JSON string
          const blob = new Blob([storageData], { type: 'application/json' }); // Create a blob
          const url = URL.createObjectURL(blob); // Create a URL for the blob
          const a = document.createElement('a'); // Create an anchor element
          a.href = url;
          a.download = 'localStorage.json'; // Set the download filename
          document.body.appendChild(a);
          a.click(); // Trigger the download
          document.body.removeChild(a); // Clean up the DOM
      }

      const importLocalStorage = (file) => {
          const reader = new FileReader();
          reader.onload = function(event) {
              const storageData = JSON.parse(event.target.result);
              for (let key in storageData) {
                  if (storageData.hasOwnProperty(key)) localStorage.setItem(key, storageData[key]);
              }
          };
          reader.readAsText(file);
      }

      // Load settings when the page is opened
      window.addEventListener('load', function () {
          loadSettings();
          // Save settings when the user changes any input
          document.querySelectorAll('.settings-field').forEach(function (element) {
              element.addEventListener('input', saveSettings);
          });
      });

      exportSettingsBtn.addEventListener('click', exportLocalStorage);

      importSettingsBtn.addEventListener('click', () => {
        if (importSettingsFile.files.length > 0) {
          importLocalStorage(importSettingsFile.files[0]);
          location.reload();
        }else alert('Please select a file to import.');
      });

      importSettingsFile.addEventListener('change', function() {
          if (importSettingsFile.files.length > 0) importSettingsFileName.textContent = importSettingsFile.files[0].name;
          else importSettingsFileName.textContent = 'No file chosen';
      });

      // Clear local storage and reset defaults
      clearSettingsBtn.addEventListener('click', () => {
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const key = localStorage.key(i);
          if (key.startsWith(appPrefix)) 
            localStorage.removeItem(key);
        }
        location.reload();
      });
    }

    //#endregion Initialization 
    //#region UI Rendering
    function clearAll(){
      notificationPanel.innerHTML = '';
      editorNotificationPanel.innerHTML = '';
      summary.innerHTML = '';
      summaryTable.innerHTML = '';
      summaryGrid.innerHTML = '';
      summaryCustom.innerHTML = '';
      modelUrl.href = '#';
      modelUrl.innerHTML = '';
      resourceUrl.href = '#';
      resourceUrl.innerHTML = '';
      previewImage.src = '';
      civitaiDisplay.innerHTML = '';
      keywordDetails.innerHTML = '';
      metadataDisplay.innerHTML = '';
      metadataEditor.value = '';
      editorHeader.style.display = "none";

      fileMetadata = {};
      civitaiMetadata = {};
      customMetadata = {};
      basemodelMetadata = {};
      vaeMetadata = {};
      safetensorsFile = null;
    }

    function showLoading(message = null) {
      loading.style.display = 'block';
      updateLoading(message, 0);
    }

    // Function to hide the loading animation
    function hideLoading() {
      loading.style.display = 'none';
    }

    function updateLoading(message, progress){
      if(message !== null) loadingMessage.innerHTML = message;
      updateProgress(progress);
    }

    function updateProgress(progress){
      if(progress || progress === 0){
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${progress}%`;
      }
    }

    function updateMetadata(metadata) {
      if(enableMetadata.checked) formatAndColorizeJSON(metadata, metadataDisplay);    
    }

    function updateMetadataEditor(metadata) {
      if(enableMetadataEditor.checked) {
        // Clean the metadata for display - unescape JSON strings
        const cleanMetadata = cleanMetadataForDisplay(metadata);
        metadataEditor.value = cleanMetadata? JSON.stringify(cleanMetadata, null, 2): '';
        editorHeader.style.display = "";
      }
    }
    
    function cleanMetadataForDisplay(metadata) {
      if (!metadata) return metadata;
      
      const cleaned = {};
      for (const [key, value] of Object.entries(metadata)) {
        if (typeof value === 'string') {
          // Try to parse as JSON to unescape it
          try {
            const parsed = JSON.parse(value);
            cleaned[key] = parsed;
          } catch (e) {
            // If it's not valid JSON, keep as string
            cleaned[key] = value;
          }
        } else {
          cleaned[key] = value;
        }
      }
      return cleaned;
    }

    function updateSummary(metadata, civitaiMetadata, customMetadata) {     
      if(enableSummary.checked){
        const summaryJson = fetchMetadataValues(summaryFields.value);
        renderSummary(summaryJson);
        const spContainer = document.getElementById('dashboardSuggestedPrompt');
        if(spContainer && customMetadata.suggested_prompt) renderSuggestedPrompt(customMetadata.suggested_prompt, spContainer);
        const twContainer = document.getElementById('triggerWordsPrompt');
        if(twContainer && civitaiMetadata?.trainedWords) renderSuggestedPrompt(civitaiMetadata.trainedWords, twContainer);
      }
    }

    async function updateCivitAiInfo(file, hash = null){
      if (enableCivitAiInfo.checked) {
        const data = await getCivitAiData(file);
        if(data?.hash) customMetadata.lora_hash = data.hash;
        if(data?.hashType) customMetadata.lora_hash_type = data.hashType;
        if(data?.autov2) customMetadata.autov2 = data.autov2;
        if(data?.autov3) customMetadata.autov3 = data.autov3;
        if (data?.data) {
          modelUrl.href = data.modelUrl;
          modelUrl.innerHTML = data.modelUrl;
          resourceUrl.href = data.resourceUrl;
          resourceUrl.innerHTML = data.resourceUrl;
          formatAndColorizeJSON(data.data, civitaiDisplay);
          previewImage.src = data.data.images[0].url;
          civitaiMetadata = data.data;
          customMetadata.civiai_model_link = modelUrl.cloneNode(true).outerHTML;
          customMetadata.civiai_resource_link = resourceUrl.cloneNode(true).outerHTML;
        }
        const baseModelHash = fileMetadata.ss_new_sd_model_hash || fileMetadata.ss_sd_model_hash;
        if(baseModelHash){
          const baseModelInfo = await getCivitAiData(null, baseModelHash);
          if(baseModelInfo && baseModelInfo.data) basemodelMetadata = baseModelInfo.data;
        }
        const vaeHash = fileMetadata.ss_new_vae_hash || fileMetadata.ss_vae_hash;
        if(vaeHash){
          const vaeInfo = await getCivitAiData(null, vaeHash);
          if(vaeInfo && vaeInfo.data) vaeMetadata = vaeInfo.data;
        }
        if (data?.data || baseModelHash || vaeHash) setCustomMetadata();
        updateSummary(fileMetadata, civitaiMetadata, customMetadata);
      }
    }

    const tagTools = {
        aggregateAndSort: (originalObject) => {
          return Object.fromEntries(
              Object.entries(
                  Object.values(originalObject).reduce((acc, subObject) => {
                      for (const [key, value] of Object.entries(subObject)) {
                          acc[key] = (acc[key] || 0) + value;
                      }
                      return acc;
                  }, {})
              ).sort(([, a], [, b]) => b - a));
        },
        sortSubproperties: (originalObject) => {
            return Object.fromEntries(
                Object.entries(originalObject).map(([key, subObject]) => [
                    key,
                    Object.fromEntries(
                        Object.entries(subObject).sort(([, a], [, b]) => b - a)
                    ),
                ])
            );
        },
        convertNumericKeysToString: (originalObject) => {
            const convertedObject = {};
            for (const [key, value] of Object.entries(originalObject)) {
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    const nestedObject = {};
                    for (const [subKey, subValue] of Object.entries(value)) {
                        const newSubKey = !isNaN(subKey) ? `(${subKey})` : subKey;
                        nestedObject[newSubKey] = subValue;
                    }
                    convertedObject[key] = nestedObject;
                } else {
                    convertedObject[key] = value;
                }
            }
            return convertedObject;
        },
        filterTopN: (obj, n) => {
            const topNEntries = Object.entries(obj).slice(0, n);
            return Object.fromEntries(topNEntries);
        },
        filterByTag: (obj, regex) => {
            const filteredObj = {};
            const pattern = typeof regex === 'string' ? new RegExp(regex) : regex;
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) 
                    if (pattern.test(key) || (typeof obj[key] === 'string' && pattern.test(obj[key]))) 
                        filteredObj[key] = obj[key];
            }
            return filteredObj;
        },
        removeTags: (obj, regex) => {
            const pattern = typeof regex === 'string' ? new RegExp(regex) : regex;
            Object.keys(obj).forEach(property => {
                if (pattern.test(property)) delete obj[property];
            });
            return obj;
        },
        isValidRegex: (regexString) => {
            try {
                new RegExp(regexString);
                return true; 
            } catch (e) {
                return false; 
            }
        },
        applyFiltersToSubproperties: (obj, filterFunction, ...args) => {
            const filteredObject = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) filteredObject[key] = filterFunction(obj[key], ...args);
            }
            return filteredObject;
        },
        listToRegex: (listString, exactMatch = false) => {
            const valuesArray = listString.split(',').map(value => value.trim());
            const escapedValues = valuesArray.map(value => value.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')); // Escape special regex characters in each value
            const pattern = exactMatch
                ? `^(${escapedValues.join('|')})$`  // Exact match: ^value1$|^value2$|...
                : `(${escapedValues.join('|')})`;   // Partial match: value1|value2|...
            return new RegExp(pattern);
        },
        getSuggestedPrompt: (tags) => {
          if(!tags) return;
          const keys = Object.keys(tags);
          const prompts = {};
          if(typeof tags[keys[0]] !== 'object')
            prompts.Prompt = Object.keys(tags).join(', ');
          else 
            for (let property in tags)
              if (tags.hasOwnProperty(property))
                prompts[property] = Object.keys(tags[property]).join(', ');
          return prompts;
        }
    }

    function updateTagFrequency(data, suggestedPrompt=false){
      try {  
        if((!enableTagFrequency.checked && !enableSuggestedPrompt.checked) || (!data?.['ss_tag_frequency'] && !customMetadata.tags)) return;
        if(data?.['ss_tag_frequency']){
          const tags = tagTools.convertNumericKeysToString(data['ss_tag_frequency']);
          customMetadata.tags = tagTools.aggregateAndSort(tags);
          customMetadata.tagsByFolder = tagTools.sortSubproperties(tags);
        }
        const filterMethod = !suggestedPrompt ? tagFrequencyFilterMethod : suggestedPromptFilterMethod;
        const filter = !suggestedPrompt ? tagFrequencyFilter : suggestedPromptFilter;
        const excludeFilterMethod = !suggestedPrompt ? tagExcludeFilterMethod : suggestedPromptExcludeFilterMethod;
        const excludeFilter = !suggestedPrompt ? tagExcludeFilter : suggestedPromptExcludeFilter;
        const filterVld = !suggestedPrompt ? tagFrequencyFilterVld : suggestedPromptFilterVld;
        const excludeFilterVld = !suggestedPrompt ? tagExcludeFilterVld : suggestedPromptExcludeFilterVld;
        const tagCount = !suggestedPrompt ? tagFrequencyCount : suggestedPromptCount;
        const byFolder = !suggestedPrompt ? tagByFolder : suggestedPromptByFolder;
        let filteredResult;
        let includeRegex;
        switch (filterMethod.value) {
          case 'regex': includeRegex = filter.value; break;
          case 'exact': includeRegex = tagTools.listToRegex(filter.value, true); break;
          case 'partial': includeRegex = tagTools.listToRegex(filter.value); break;
        }
        let excludeRegex;
        switch (excludeFilterMethod.value) {
          case 'regex': excludeRegex = excludeFilter.value; break;
          case 'exact': excludeRegex = tagTools.listToRegex(excludeFilter.value, true); break;
          case 'partial': excludeRegex = tagTools.listToRegex(excludeFilter.value); break;
        }
        filterVld.innerHTML = !tagTools.isValidRegex(includeRegex) ? 'Invalid regex!' : '';
        excludeFilterVld.innerHTML = !tagTools.isValidRegex(excludeRegex) ? 'Invalid regex!' : '';
        if(!tagTools.isValidRegex(includeRegex)) includeRegex = '';
        if(!tagTools.isValidRegex(excludeRegex)) excludeRegex = '';
        if(byFolder.checked) {
          filteredResult = JSON.parse(JSON.stringify(customMetadata.tagsByFolder));
          if(includeRegex) filteredResult = tagTools.applyFiltersToSubproperties(filteredResult, tagTools.filterByTag, includeRegex);
          if(excludeRegex) filteredResult = tagTools.applyFiltersToSubproperties(filteredResult, tagTools.removeTags, excludeRegex);
          if(tagCount.value && parseInt(tagCount.value)>0) filteredResult = tagTools.applyFiltersToSubproperties(filteredResult, tagTools.filterTopN, tagCount.value);
        }else{
          filteredResult = JSON.parse(JSON.stringify(customMetadata.tags));
          if(includeRegex) filteredResult = tagTools.filterByTag(filteredResult, includeRegex);
          if(excludeRegex) filteredResult = tagTools.removeTags(filteredResult, excludeRegex);
          if(tagCount.value && parseInt(tagCount.value)>0) filteredResult = tagTools.filterTopN(filteredResult, tagCount.value);
        }
        if(!suggestedPrompt) formatAndColorizeJSON(filteredResult, keywordDetails);
        else {
          let prompt = tagTools.getSuggestedPrompt(filteredResult);
          if(!byFolder.checked) prompt = [prompt.Prompt];
          renderSuggestedPrompt(prompt, suggestedPromptDetails);
          customMetadata.suggested_prompt = prompt;
          const spContainer = document.getElementById('dashboardSuggestedPrompt');
          if(spContainer && customMetadata.suggested_prompt) renderSuggestedPrompt(customMetadata.suggested_prompt, spContainer);
        }
      } catch (error) { console.error(error); }
    }

    function renderSuggestedPrompt(prompt, targetElem) {
        const addRow = (table, key, value) => {
            const row = document.createElement('tr');
            if (key !== null) {
                const keyCell = document.createElement('td');
                keyCell.textContent = key;
                row.appendChild(keyCell);
            }
            const valueCell = document.createElement('td');
            valueCell.appendChild(createCopyableTextElem(value));
            row.appendChild(valueCell);
            table.appendChild(row);
        }
        targetElem.innerHTML = '';
        const table = document.createElement('table');
        table.className = 'summary-table';
        if (Array.isArray(prompt)) prompt.forEach(value => addRow(table, null, value));
        else Object.entries(prompt).forEach(([key, value]) => addRow(table, key, value));
        targetElem.appendChild(table);
    }

    //Toggle UI between dark and light modes
    function toggleDarkMode(){
      document.body.classList.toggle('dark-theme');
    }

    // Format a JSON object into colorized HTML
    function colorizeJSON(json, removeSurroundingQuotes) {
      const formattedJSON = JSON.stringify(json, null, 2);
      const coloredJSON = formattedJSON && formattedJSON.replace(
          /"(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null|"undefined")\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
          function(match) {
              let cls = 'number';
              if (/^(null|"?undefined"?)$/.test(match)) 
                cls = 'null';
              else if (/^(true|false)$/.test(match)) 
                cls = 'boolean';
              else if (/^"/.test(match)) {
                cls = /:$/.test(match) ? 'key' : 'string';
                if (cls === 'string' && /^("https?:\/\/)/.test(match)) { // Check if the string is a url
                    match = `<a target='_blank' href=${match}>${removeSurroundingQuotes ? match.replaceAll('"','') :match}</a>`; 
                    cls = 'url'; 
                }
                else if (cls === 'string' && /<(lora|lyco):/.test(match)) { // HTML encode prompt values
                    const tempElement = document.createElement('div');
                    tempElement.textContent = match;
                    match = tempElement.innerHTML;
                }
                else if (cls === 'string' && /\<[^\>]+\>/.test(match)) { // Check if the string contains HTML tags
                    match = match.replace(/\\"/g, '"').replace(/\\n/g,''); // Replace escaped characters
                    cls = 'html'; 
                }
              }
              if(removeSurroundingQuotes) match = match.replace(/^"(.*)"$/, '$1');
              return `<span class="${cls}">${match}</span>`;
          }
      );
      return coloredJSON;
    }

    function formatAndColorizeJSON(json, targetElement) {
        targetElement.innerHTML = colorizeJSON(json);
    }

    function replacePlaceholders(text, data=null, colorize=true, undefinedText=null) {
      const replacedContent = text.replace(/{{([^}]+)}}/g, (match, placeholder) => {
        placeholder = placeholder.replace(" ", "");
        let remove = false;
        if (placeholder.endsWith('?')) { 
          remove = true;
          placeholder = placeholder.slice(0, -1); 
        }
        const value = data !== null ? data[placeholder] : fetchMetadataValue(placeholder);
        if (typeof value === 'object') return (colorize?`<pre>${colorizeJSON(value)}</pre>`:value);
        else if(value !== undefined && value !== "undefined") return colorize ? colorizeJSON(value, true) : value;
        else if(remove) return '';
        else if(undefinedText) return undefinedText;
        else '<span class="null">undefined<span>';
      });
      return replacedContent;
    }

    function showTooltip(message, event, timeout = 1500) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = message;
        tooltip.style.left = `${event.pageX - 35}px`;
        tooltip.style.top = `${event.pageY - 30}px`;
        document.body.appendChild(tooltip);
        setTimeout(() => { tooltip.remove(); }, timeout);
    }

    function createCopyableTextElem(string) {
      const elem = document.createElement('span');
      elem.textContent = string;
      elem.className = 'copyable-item';
      elem.addEventListener('click', function(event) {
          navigator.clipboard.writeText(string).then(() => {
              showTooltip('Copied!', event); 
          }).catch(err => {
              console.error('Failed to copy text: ', err);
          });
      });
      return elem;
    }

    function renderSummary(summaryJson){
      //Render JSON
      formatAndColorizeJSON(summaryJson, summary); //Render JSON Summary
      //Render Table 
      const rows = Object.entries(summaryJson).map(([key, value]) => {
        const dataType = value === null || value === undefined || value === "undefined" ? "null" : typeof value;
        const formattedValue = dataType === 'object' ? `<pre>${colorizeJSON(value)}</pre>` : colorizeJSON(value, true);
        return `<tr><td>${key}</td><td>${formattedValue}</td></tr>`;
      });
      summaryTable.innerHTML = `<table>${rows.join('')}</table>`;
      //Render Grid
      const grid = Object.entries(summaryJson).map(([key, value]) => {
        return replacePlaceholders(summaryGridTemplate.innerHTML, { key, value });
      }).join('');
      summaryGrid.innerHTML = `<div class="summary-grid">${grid}</div>`
      //Render Custom
      summaryCustom.innerHTML = replacePlaceholders(customTemplate.value, null, true, "<span class='null'>-</span>");
    }

    function addListItem(listId, itemTemplateId, data=null) {
      const template = document.getElementById(itemTemplateId).innerHTML;
      const html = data===null ? template.replace(/\{\{.*?\}\}/g, '') : replacePlaceholders(template, data, false);
      document.getElementById(listId).insertAdjacentHTML('beforeend', html);
    }

    function removeListItem(button) {
      let currentElement = button;
      while (currentElement) {
          if (currentElement.classList.contains('list-item')) 
              currentElement.remove();
          currentElement = currentElement.parentNode;
      }
    }


    //#endregion UI Rendering
    //#region UI Actions
    function copyToClipboard(elementId, event) {
      const textToCopy = document.getElementById(elementId);
      const textarea = document.createElement('textarea');
      textarea.value = textToCopy.textContent;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      showTooltip('Copied!', event);
    }

    async function saveMetadataFromEditor() {
      editorNotificationPanel.innerHTML = '';
      
      try {
        // Validate JSON first
        const newMetadata = JSON.parse(metadataEditor.value);
        
        // Check if we're in server mode and have a server file
        if (safetensorsFile?.isServerFile) {
          // Debug: log the path being used
          console.log('Saving metadata to:', safetensorsFile.relative_path);
          
          // Save to server - the backend will handle proper escaping
          const response = await fetch(`/api/metadata/${safetensorsFile.relative_path}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ metadata: newMetadata })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Server error: ${response.statusText}`);
          }
          
          // Update local metadata with the response from server
          const result = await response.json();
          fileMetadata = result.metadata;
          updateMetadata(fileMetadata);
          
          editorNotificationPanel.innerHTML = 'Metadata saved successfully!';
          editorNotificationPanel.style.color = 'var(--string)';
        } else {
          // For local files, just update the display
          fileMetadata = newMetadata;
          updateMetadata(fileMetadata);
          
          editorNotificationPanel.innerHTML = 'Metadata updated! (Note: Changes are not saved to file)';
          editorNotificationPanel.style.color = 'var(--number)';
        }
        
      } catch (error) {
        if (error instanceof SyntaxError) {
          editorNotificationPanel.innerHTML = 'Invalid JSON: ' + error.message;
        } else {
          editorNotificationPanel.innerHTML = 'Error: ' + error.message;
        }
        editorNotificationPanel.style.color = 'var(--error)';
      }
    }
    
    // Filter functions for server files
    function filterFiles() {
      const searchTerm = fileSearchInput.value.toLowerCase().trim();
      
      if (searchTerm === '') {
        filteredFiles = serverFiles;
      } else {
        filteredFiles = serverFiles.filter(file => 
          file.name.toLowerCase().includes(searchTerm) ||
          file.relative_path.toLowerCase().includes(searchTerm)
        );
      }
      
      renderFilesList();
      updateSearchStats();
    }
    
    function clearSearch() {
      fileSearchInput.value = '';
      filteredFiles = serverFiles;
      renderFilesList();
      updateSearchStats();
      fileSearchInput.focus();
    }
    
    function updateSearchStats() {
      const searchTerm = fileSearchInput.value.trim();
      if (searchTerm === '') {
        fileSearchStats.textContent = `${serverFiles.length} files total`;
        clearSearchBtn.style.display = 'none';
      } else {
        fileSearchStats.textContent = `${filteredFiles.length} of ${serverFiles.length} files match "${searchTerm}"`;
        clearSearchBtn.style.display = 'inline-block';
      }
    }
    
    //#endregion UI Events
    //#region Lora/Safetensors Utilities
    function setCustomMetadata(){
      try {
          const objArray = JSON.parse(customFields.value);
          if (Array.isArray(objArray) && objArray.length > 0) {
              const evaluatedObj = objArray.reduce((acc, obj, index) => {
                  if (typeof obj === 'object' && 'label' in obj && 'calc' in obj && typeof obj.calc === 'string') {
                      try{
                        // Add timeout protection for eval operations
                        const startTime = Date.now();
                        acc[obj.label] = eval(obj.calc);
                        const evalTime = Date.now() - startTime;
                        if (evalTime > 1000) {
                          console.warn(`Custom field "${obj.label}" took ${evalTime}ms to evaluate`);
                        }
                      }
                      catch(e) {
                        console.warn(`Error evaluating expression for custom field "${obj.label}".`, obj, e);
                        // Don't show error in notification panel for server mode to avoid spam
                        if(!isServerMode || obj.showError){
                          notificationPanel.innerHTML += `Error evaluating expression for custom field "${obj.label}".<br>`;
                        }
                        acc[obj.label] = undefined; // Set to undefined instead of leaving blank
                      }
                      customMetadata[obj.label] = acc[obj.label];
                  } else {
                      console.error('Invalid object format or missing fields:', obj);
                  }
                  return acc;
              }, {});
              return evaluatedObj;
          } else {
              console.log('No custom fields defined or empty array.');
              return {};
          }
      } catch (error) {
          console.error('Error evaluating expressions:', error.message);
          notificationPanel.innerHTML += `Error processing custom fields: ${error.message}<br>`;
          return null;
      }
    }

    function fetchMetadataValues(fields) {
      const fieldList = fields.split(',').map(value => value.trim());
      return Object.fromEntries( fieldList.map(item => [item, fetchMetadataValue(item)]) );
    }

    function fetchMetadataValue(field) {
      if(field.startsWith('civitai.') && civitaiMetadata && field.substring(8) in civitaiMetadata)
        return civitaiMetadata[field.substring(8)];
      else if(field.startsWith('custom.') && customMetadata && field.substring(7) in customMetadata)
        return customMetadata[field.substring(7)];
      else if(field in fileMetadata)
        return fileMetadata[field];
      else if(showUndefinedSummaryValues.checked)
        return "undefined";
      else 
        return undefined;
    }

    async function getCivitAiData(file, hash = null) {
      let baseApiUrl = 'https://civitai.com/api/v1/model-versions/by-hash/';
      let modelApiUrl = `https://civitai.com/api/v1/models/`;
      const baseModelUrl = 'https://civitai.com/models/';
      const versionParam = '?modelVersionId=';
      let finalHash = hash;
      let hashType;
      let autov2;
      let autov3;
      
      // Only show loading if not already showing (for server file downloads)
      if (loading.style.display !== 'block') {
        showLoading('Processing...');
      } else {
        updateLoading('Processing...', 30);
      }
      if(file){
        try{
          // Check if this is a server file that wasn't fully downloaded
          if (file.isServerFile) {
            updateLoading('Using server-provided hashes...', 60);
            // Use hashes provided by the server
            if (file.serverHashes) {
              autov2 = file.serverHashes.AutoV2;
              autov3 = file.serverHashes.AutoV3;
              notificationPanel.innerHTML += 'Using server-calculated hashes for CivitAI lookup. ';
            } else {
              notificationPanel.innerHTML += 'No hashes available for server-loaded file. ';
            }
          } else {
            const TWO_GB = 2 * 1024 * 1024 * 1024;
            updateLoading('Calculating AutoV2 hash...', 35);
            if (file.size > TWO_GB) {
              
              autov2 = await calculateHashInChunks(file);
              autov2 = autov2.substring(0,10);
            }
            else {
              autov2 = await calculateFileHash(file);
              autov2 = autov2.substring(0,10);
              updateLoading('Calculating AutoV3 hash...', 60);
              autov3 = await calculateAutoV3Hash(file);
              autov3 = autov3.substring(0,12);
            }
          }
        } catch(error){
          if (error.message === 'Unable to read the file.') 
            notificationPanel.innerHTML = (Object.keys(fileMetadata).length ? 'Metadata was found, but t':'T' ) + 'here was a problem calculating the hash. The file size may be too large.';
        }
      }
      updateLoading('CivitAI lookup...', 85);
      const fetchWithHash = async (url) => {
        try {
          const response = await fetch(url);
          if (!response.ok) return null;
          return response.json();
        } catch (error) {
          if (error instanceof TypeError) notificationPanel.innerHTML = "CivitAI lookup failed, possibly due to a CORS restriction or network error...";
          else console.log('There was a problem:', error);
        }
      };

      const fetchWithFallback = async () => {
        let data = hash ? await fetchWithHash(baseApiUrl + hash) : null;
        if (!data && autov2) {
          data = await fetchWithHash(baseApiUrl + autov2);
          if(data){
            finalHash = autov2;
            hashType = 'AutoV2';
          }
        }
        if (!data && autov3) {
          data = await fetchWithHash(baseApiUrl + autov3);
          if(data){
            finalHash = autov3;
            hashType = 'AutoV3';
          }
        }
        if(data) data.model = await fetchWithHash(modelApiUrl + data.modelId);
        return data;
      };

      return fetchWithFallback()
        .then(data => {
          if (data) return { data:data, hash:finalHash, hashType:hashType, autov2:autov2, autov3:autov3, modelUrl:baseModelUrl + data.modelId + versionParam + data.id, resourceUrl:baseApiUrl + finalHash };
          return { hash:finalHash, hashType:hashType, autov2:autov2, autov3:autov3 };
        })
        .catch(error => {
          console.error('There was a problem:', error);
        })
        .finally(()=>{hideLoading();});
    }
    //#endregion Lora/Safetensors Utilities
    //#region Encryption Utilities
    //Calculate SHA-256 hash of the entire file (AutoV2 hash)
    function calculateFileHash(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async () => {
          const buffer = reader.result;
          try {
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(byte => ('00' + byte.toString(16)).slice(-2)).join('');
            resolve(hashHex);
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => { reject(new Error('Unable to read the file.')); };
        reader.readAsArrayBuffer(file);
      });
    }

    //Calculate SHA-256 hash of a file, without metadata section (AutoV3 hash)
    function calculateAutoV3Hash(file) {
        return new Promise(async (resolve, reject) => {
            try {
                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        const fileBuffer = reader.result;
                        const dataView = new DataView(fileBuffer);
                        const n = dataView.getUint32(0, true); // Read the first 8 bytes as an integer in little-endian format                     
                        const offset = n + 8; // Calculate the offset
                        const fileBytesToHash = new Uint8Array(fileBuffer, offset); // Extract data from  file starting at calculated offset       
                        crypto.subtle.digest('SHA-256', fileBytesToHash) // Calculate the SHA-256 hash of the extracted data
                            .then(hashBuffer => {
                                const hashArray = Array.from(new Uint8Array(hashBuffer));
                                const hashHex = hashArray.map(byte => ('00' + byte.toString(16)).slice(-2)).join('');
                                resolve(hashHex);
                            })
                            .catch(err => reject(err));
                    } catch (error) {
                        console.error('Error processing file:', error);
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Unable to read the file.'));
                reader.readAsArrayBuffer(file);
            } catch (error) {
                reject(error);
            }
        });
    }

    async function calculateHashInChunks(file) {
        const chunkSize = 16 * 1024 * 1024;  // 16 MB chunk size
        const totalChunks = Math.ceil(file.size / chunkSize);
        updateProgress(0);
        const sha256 = await hashwasm.createSHA256();
        let chunksProcessed = 0;
        // Read and process each chunk
        for (let i = 0; i < totalChunks; i++) {
            const chunk = file.slice(i * chunkSize, (i + 1) * chunkSize);
            const chunkArrayBuffer = await chunk.arrayBuffer();
            // Update the hash with the current chunk data
            sha256.update(new Uint8Array(chunkArrayBuffer));
            // Update and display the progress
            chunksProcessed++;
            const progress = Math.round((chunksProcessed / totalChunks) * 100);
            updateProgress(progress);
        }
        // Finalize and get the hash as a hex string
        const finalHashHex = sha256.digest('hex');
        return finalHashHex;  // Return the final hash as a hex string
    }
    //#endregion Encryption Utilities
    
    //#region Modal Functions
    function openEditModal() {
      const modal = document.getElementById('editModal');
      const textarea = document.getElementById('editMetadataTextarea');
      
      // Get current metadata and populate the textarea with clean JSON
      if (fileMetadata && Object.keys(fileMetadata).length > 0) {
        const cleanMetadata = cleanMetadataForDisplay(fileMetadata);
        textarea.value = JSON.stringify(cleanMetadata, null, 2);
      } else {
        textarea.value = '{}';
      }
      
      modal.style.display = 'block';
      textarea.focus();
    }
    
    function closeEditModal() {
      const modal = document.getElementById('editModal');
      modal.style.display = 'none';
    }
    
    async function saveMetadata() {
      const textarea = document.getElementById('editMetadataTextarea');
      const modal = document.getElementById('editModal');
      
      try {
        // Validate JSON first
        const newMetadata = JSON.parse(textarea.value);
        
        // Check if we're in server mode and have a server file
        if (safetensorsFile?.isServerFile) {
          // Debug: log the path being used
          console.log('Saving metadata to:', safetensorsFile.relative_path);
          
          // Save to server - the backend will handle proper escaping
          const response = await fetch(`/api/metadata/${safetensorsFile.relative_path}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ metadata: newMetadata })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Server error: ${response.statusText}`);
          }
          
          // Update local metadata with the response from server
          const result = await response.json();
          fileMetadata = result.metadata;
          updateMetadata(fileMetadata);
          updateMetadataEditor(fileMetadata);
          
          closeEditModal();
          showTooltip('Metadata saved successfully!', null, 2000);
        } else {
          // For local files, update the metadata display
          fileMetadata = newMetadata;
          updateMetadata(fileMetadata);
          updateMetadataEditor(fileMetadata);
          
          closeEditModal();
          showTooltip('Metadata updated! (Note: Changes are not saved to file)', null, 2000);
        }
        
      } catch (error) {
        if (error instanceof SyntaxError) {
          alert('Invalid JSON: ' + error.message);
        } else {
          alert('Error: ' + error.message);
        }
      }
    }
    
    // Close modal when clicking outside of it
    window.onclick = function(event) {
      const modal = document.getElementById('editModal');
      if (event.target === modal) {
        closeEditModal();
      }
    }
    
    // Close modal with Escape key
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        const modal = document.getElementById('editModal');
        if (modal.style.display === 'block') {
          closeEditModal();
        }
      }
    });
    //#endregion Modal Functions
  </script>
</body>
</html>
